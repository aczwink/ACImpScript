#pragma once
//SJCLib
#include <SJCLib.h>
//Namespaces
using namespace SJCLib;
//Definitions
#define UCS_KEYWORD_ARRAY "array"
#define UCS_KEYWORD_CONST "const"
#define UCS_KEYWORD_FOR "for"
#define UCS_KEYWORD_IF "if"
#define UCS_KEYWORD_INT "int"
#define UCS_KEYWORD_NEW "new"
#define UCS_KEYWORD_RETURN "return"
#define UCS_KEYWORD_VOID "void"

namespace SourceTokens
{
	enum ESourceToken
	{
		TOKEN_ILLEGAL,
		TOKEN_END,
		TOKEN_TABSPACE,
		TOKEN_LINEFEED,
		TOKEN_CARRIAGERETURN,
		TOKEN_LITERAL,
		TOKEN_OPENPAREN,
		TOKEN_CLOSEPAREN,
		TOKEN_PLUS,
		TOKEN_PLUSPLUS,
		TOKEN_MINUS,
		TOKEN_NUMBER,
		TOKEN_SINGLELINECOMMENT,
		TOKEN_MULTILINECOMMENT,
		TOKEN_COMMA,
		TOKEN_SEMICOLON,
		TOKEN_LESSTHAN,
		TOKEN_LESSOREQUAL,
		TOKEN_ASSIGN,
		TOKEN_EQUALS,
		TOKEN_IDENTIFIER,
		TOKEN_OPENBRACE,
		TOKEN_CLOSEBRACE,
		TOKEN_SQUAREDBRACKETOPEN,
		TOKEN_SQUAREDBRACKETCLOSE,
		
		TOKEN_ARRAY,
		TOKEN_CONST,
		TOKEN_FOR,
		TOKEN_IF,
		TOKEN_INT,
		TOKEN_NEW,
		TOKEN_RETURN,
		TOKEN_VOID,
		
		TOKEN_ELSE,
		TOKEN_WHILE,
		TOKEN_FLOAT,
		TOKEN_STRING,
		TOKEN_NOTEQUALS,
		TOKEN_GREATERTHAN,
		TOKEN_GREATEROREQUAL,
		TOKEN_MULTIPLY,
		TOKEN_DIVIDE,
		TOKEN_MODULO,
		TOKEN_NOT,
		TOKEN_MINUSMINUS,
		TOKEN_FLOATNUMBER,
	};
}

//DFA
class CSourceLexer
{
	friend class CParser;
	
	enum EState
	{
		STATE_ILLEGAL,
		STATE_START,
		STATE_END,
		STATE_FINISHED,
		STATE_TABSPACE,
		STATE_LINEFEED,
		STATE_CARRIAGERETURN,
		STATE_UNCLOSEDLITERAL,
		STATE_CLOSEDLITERAL,
		STATE_OPENPAREN,
		STATE_CLOSEPAREN,
		STATE_MULTIPLY,
		STATE_PLUS,
		STATE_COMMA,
		STATE_PLUSPLUS,
		STATE_MINUS,
		STATE_SLASH,
		STATE_NUMBER,
		STATE_SINGLELINECOMMENT,
		STATE_MULTILINECOMMENT,
		STATE_SEMICOLON,
		STATE_LESSTHAN,
		STATE_LESSOREQUAL,
		STATE_ASSIGN,
		STATE_SQUAREDBRACKETOPEN,
		STATE_SQUAREDBRACKETCLOSE,
		STATE_EQUALS,
		STATE_IDENTIFIER,
		STATE_OPENBRACE,
		STATE_CLOSEBRACE,
	};

	enum ECharClass
	{
		CC_ILLEGAL,
		CC_NULLBYTE,
		CC_TABSPACE,
		CC_LINEFEED,
		CC_CARRIAGERETURN,
		CC_INVERTEDCOMMA,
		CC_OPENPAREN,
		CC_CLOSEPAREN,
		CC_MULTIPLY,
		CC_PLUS,
		CC_COMMA,
		CC_MINUS,
		CC_SLASH,
		CC_NUMBER,
		CC_SEMICOLON,
		CC_LESSTHAN,
		CC_EQUALS,
		CC_SQUAREDBRACKETOPEN,
		CC_SQUAREDBRACKETCLOSE,
		CC_LETTER,
		CC_OPENBRACE,
		CC_CLOSEBRACE,
		CC_INVALID,
	};
private:
	//Variables
	const char *pSource;
	CString tokenValue;
	//Functions
	ECharClass GetCharClass(char c);
	EState GetNextState(EState state, ECharClass cc);
	SourceTokens::ESourceToken GetTokenType(EState state);
public:
	//Functions
	SourceTokens::ESourceToken GetNextToken();
	const CString &GetTokenValue();
	void Init(const char *pSource);
};